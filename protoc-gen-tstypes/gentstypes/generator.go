package gentstypes

// TODO: add nested messages support
// TODO: add nested enum support

import (
	"bytes"
	"fmt"
	"regexp"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/Masterminds/sprig"
	"github.com/davecgh/go-spew/spew"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
	"github.com/jhump/protoreflect/desc"
	"github.com/tmc/grpcutil/protoc-gen-tstypes/opts"
)

const indent = "    "

type Parameters struct {
	AsyncIterators        bool
	Observables           bool
	DeclareNamespace      bool
	OutputNamePattern     string
	DumpRequestDescriptor bool
	EnumsAsInt            bool
	OriginalNames         bool
	Verbose               int
	Int64AsString         bool
	// TODO: allow template specification?
}

type Generator struct {
	*bytes.Buffer
	indent   string
	Request  *plugin.CodeGeneratorRequest
	Response *plugin.CodeGeneratorResponse
}

type OutputNameContext struct {
	Dir        string
	BaseName   string
	Descriptor *desc.FileDescriptor
	Request    *plugin.CodeGeneratorRequest
}

func New() *Generator {
	return &Generator{
		Buffer:   new(bytes.Buffer),
		Request:  new(plugin.CodeGeneratorRequest),
		Response: new(plugin.CodeGeneratorResponse),
	}
}

func (g *Generator) incIndent() {
	g.indent += indent
}

func (g *Generator) decIndent() {
	g.indent = string(g.indent[:len(g.indent)-len(indent)])
}

func (g *Generator) W(s string) {
	g.w(s)
	g.Buffer.WriteString("\n")
}

func (g *Generator) w(s string) {
	g.Buffer.WriteString(g.indent)
	g.Buffer.WriteString(s)
}

func (g *Generator) wcomment(s string) {
	if s != "" {
		for _, line := range strings.Split(strings.TrimSuffix(s, "\n"), "\n") {
			g.W(fmt.Sprintf("//%s", line))
		}
	}
}

var s = &spew.ConfigState{
	Indent:                  " ",
	DisableMethods:          true,
	SortKeys:                true,
	SpewKeys:                true,
	MaxDepth:                12,
	DisablePointerAddresses: true,
	DisableCapacities:       true,
}

func genName(r *plugin.CodeGeneratorRequest, f *desc.FileDescriptor, outPattern string) string {
	// TODO: consider using go_package if present?

	n := filepath.Base(f.GetName())
	if strings.HasSuffix(n, ".proto") {
		n = n[:len(n)-len(".proto")]
	}
	ctx := &OutputNameContext{
		Dir:        filepath.Dir(f.GetName()),
		BaseName:   n,
		Descriptor: f,
		Request:    r,
	}
	var t = template.Must(template.New("gentstypes/generator.go:genName").Funcs(sprig.FuncMap()).Parse(outPattern))
	buf := new(bytes.Buffer)
	if err := t.Execute(buf, ctx); err != nil {
		log.Fatalln("issue rendering template:", err)
	}
	return buf.String()
}

func (g *Generator) GenerateAllFiles(params *Parameters) {
	g.W("// Code generated by protoc-gen-tstypes. DO NOT EDIT.\n")
	files, err := desc.CreateFileDescriptors(g.Request.ProtoFile)
	if params.DumpRequestDescriptor {
		s.Fdump(os.Stderr, g.Request)
	}
	if err != nil {
		log.Fatal(err)
	}
	names := []string{}
	for _, fname := range g.Request.FileToGenerate {
		names = append(names, fname)
	}
	sort.Strings(names)
	for _, n := range names {
		f := files[n]
		g.generate(f, params)
	}
}


type GenerateFileName func(f *desc.FileDescriptor) string

func (g *Generator) generate(f *desc.FileDescriptor, params *Parameters) {
	if params.Observables {
		g.W("import { Observable } from 'rxjs';")
		g.W("import { Metadata } from 'grpc';")
	}

	// TODO: consider best order
	ns := params.DeclareNamespace && f.GetPackage() != ""
	if ns {
		g.W(fmt.Sprintf("declare namespace %s {\n", f.GetPackage()))
		g.incIndent()
	}

	gfn := func(otherFile *desc.FileDescriptor) string {
		otherFileName := genName(g.Request, otherFile, params.OutputNamePattern) 
		ownFileName := genName(g.Request, f, params.OutputNamePattern) 
		rel, _ := filepath.Rel(filepath.Dir(ownFileName), otherFileName)
		if strings.HasPrefix(rel, "../") {
			return rel;
		}
		return fmt.Sprintf("./%s", rel)
	}

	g.generateEnums(f.GetEnumTypes(), params)
	g.generateMessages(f.GetMessageTypes(), params, gfn)
	g.generateServices(f.GetServices(), params, gfn)

	if ns {
		g.decIndent()
		g.W("}\n")
	}
	n := genName(g.Request, f, params.OutputNamePattern)
	if params.Verbose > 0 {
		fmt.Fprintln(os.Stderr, "generating", n)
	}
	g.Response.File = append(g.Response.File, &plugin.CodeGeneratorResponse_File{
		Name:    proto.String(n),
		Content: proto.String(g.String()),
	})
	g.Buffer.Reset()
}

func (g *Generator) generateMessages(messages []*desc.MessageDescriptor, params *Parameters, gfn GenerateFileName) {
	for _, m := range messages {
		g.generateMessage(m, params, gfn)
	}
}
func (g *Generator) generateEnums(enums []*desc.EnumDescriptor, params *Parameters) {
	for _, e := range enums {
		g.generateEnum(e, params)
	}
}
func (g *Generator) generateServices(services []*desc.ServiceDescriptor, params *Parameters, gfn GenerateFileName) {
	for _, e := range services {
		g.generateService(e, params, gfn)
	}
}

func (g *Generator) generateMessage(m *desc.MessageDescriptor, params *Parameters, gfn GenerateFileName) {
	// TODO: namespace messages?
	for _, e := range m.GetNestedEnumTypes() {
		g.generateEnum(e, params)
	}
	for _, m := range m.GetNestedMessageTypes() {
		g.generateMessage(m, params, gfn)
	}
	name := packageQualifiedName(m)

	fieldRequiredDefault := false

	if o, err := proto.GetExtension(m.AsDescriptorProto().Options, opts.E_FieldDefaults); err == nil {
		if o, ok := o.(*opts.Options); ok {
			fieldRequiredDefault = o.GetRequired()
		}
	}

	g.wcomment(m.GetSourceInfo().GetLeadingComments())
	g.W(fmt.Sprintf("export interface %s {", name))
	for _, f := range m.GetFields() {
		name := f.GetName()
		if !params.OriginalNames {
			name = f.GetJSONName()
		}
		required := fieldRequiredDefault
		e, err := proto.GetExtension(f.AsFieldDescriptorProto().Options, opts.E_Field)
		if err == nil {
			if e, ok := e.(*opts.Options); ok {
				required = e.GetRequired()
			}
		}
		suffix := ""
		if !required {
			suffix = "?"
		}

		g.incIndent()
		g.wcomment(f.GetSourceInfo().GetLeadingComments())
		g.decIndent()
		trailingComment := ""
		if comment := f.GetSourceInfo().GetTrailingComments(); comment != "" {
			trailingComment = " // " + strings.TrimSpace(comment)
		}
		g.W(fmt.Sprintf(indent+"%s%s: %s;%s", name, suffix, fieldType(f, params, gfn), trailingComment))
	}
	g.W("}\n")
}

func fieldType(f *desc.FieldDescriptor, params *Parameters, gfn GenerateFileName) string {
	t := rawFieldType(f, params, gfn)
	if f.IsMap() {
		return fmt.Sprintf("{ [key: %s]: %s }", rawFieldType(f.GetMapKeyType(), params, gfn), rawFieldType(f.GetMapValueType(), params, gfn))
	}
	if f.IsRepeated() {
		return fmt.Sprintf("Array<%s>", t)
	}
	return t
}

func rawFieldType(f *desc.FieldDescriptor, params *Parameters, gfn GenerateFileName) string {
	switch f.GetType() {
	case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_FLOAT:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_INT32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_UINT32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_FIXED32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_SINT32:
		return "number"
	case descriptor.FieldDescriptorProto_TYPE_INT64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_UINT64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_FIXED64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
		fallthrough
	case descriptor.FieldDescriptorProto_TYPE_SINT64:
		if params.Int64AsString {
			return "string"
		} else {
			return "number"
		}
	case descriptor.FieldDescriptorProto_TYPE_BOOL:
		return "boolean"
	case descriptor.FieldDescriptorProto_TYPE_STRING:
		return "string"
	case descriptor.FieldDescriptorProto_TYPE_BYTES:
		return "Uint8Array"
	case descriptor.FieldDescriptorProto_TYPE_ENUM:
		t := f.GetEnumType()
		return qualifiedTypeName(t, f.GetFile(), gfn)
	case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
		t := f.GetMessageType()
		return qualifiedTypeName(t, f.GetFile(), gfn)
	}
	return "any /*unknown*/"
}

func packageQualifiedName(e desc.Descriptor) string {
	name := e.GetName()
	var c desc.Descriptor
	for c = e.GetParent(); c.GetParent() != nil; c = c.GetParent() {
		name = fmt.Sprintf("%v_%v", c.GetName(), name)
	}
	return name
}

func (g *Generator) generateEnum(e *desc.EnumDescriptor, params *Parameters) {
	name := packageQualifiedName(e)
	g.W(fmt.Sprintf("export enum %s {", name))
	for _, v := range e.GetValues() {
		if params.EnumsAsInt {
			g.W(fmt.Sprintf("    %s = %v,", v.GetName(), v.GetNumber()))
		} else {
			g.W(fmt.Sprintf("    %s = \"%v\",", v.GetName(), v.GetName()))
		}
	}
	g.W("}")
}

// https://godoc.org/github.com/jhump/protoreflect/desc#MessageDescriptor
func qualifiedTypeName(msg desc.Descriptor, relativeTo *desc.FileDescriptor, gfn GenerateFileName) string {
	if msg.GetFile().GetFullyQualifiedName() == relativeTo.GetFullyQualifiedName() {
		return packageQualifiedName(msg)
	}
	
	matched, err := regexp.MatchString(`^google\.protobuf\.`, msg.GetFullyQualifiedName())
	if err == nil && matched == true {
		return fmt.Sprintf("import('protobufjs').common.I%s", msg.GetName())
	}

	importFrom := gfn(msg.GetFile())
	removeExtension := regexp.MustCompile(`(?:\.d)?\.tsx?$`)
	importFrom = removeExtension.ReplaceAllString(importFrom, "")

	return fmt.Sprintf(`import("%s").%s`, importFrom, msg.GetName())
}

func (g *Generator) generateService(service *desc.ServiceDescriptor, params *Parameters, gfn GenerateFileName) {
	g.W(fmt.Sprintf("export interface %sService {", service.GetName()))
	g.incIndent()
	g.generateServiceMethods(service, params, gfn)
	g.decIndent()
	g.W(fmt.Sprintf("}"))
}

func (g *Generator) generateServiceMethods(service *desc.ServiceDescriptor, params *Parameters, gfn GenerateFileName) {
	for _, m := range service.GetMethods() {
		g.generateServiceMethod(m, params, gfn)
	}
}

//"google.protobuf.Timestamp":   "import('protobufjs').common.ITimestamp",

func (g *Generator) generateServiceMethod(method *desc.MethodDescriptor, params *Parameters, gfn GenerateFileName) {
	i := qualifiedTypeName(method.GetInputType(), method.GetFile(), gfn)
	o := qualifiedTypeName(method.GetOutputType(), method.GetFile(), gfn)
	if params.AsyncIterators {
		if method.IsServerStreaming() {
			o = fmt.Sprintf("AsyncIterator<%s>", o)
		}
		if method.IsClientStreaming() {
			i = fmt.Sprintf("AsyncIterator<%s>", i)
		}
		g.W(fmt.Sprintf("%s: (r:%s) => %s;", method.GetName(), i, o))
	} else if params.Observables { 
		if method.IsServerStreaming() {
			o = fmt.Sprintf("Observable<%s>", o)
		} else {
			o = fmt.Sprintf("%s | Observable<%s>", o, o)
		}
		if method.IsClientStreaming() {
			i = fmt.Sprintf("Observable<%s>", i)
		}
		g.W(fmt.Sprintf("%s: (r:%s, meta: Metadata) => %s;", method.GetName(), i, o))
	} else {
		ss, cs := method.IsServerStreaming(), method.IsClientStreaming()
		if !(ss || cs) {
			g.W(fmt.Sprintf("%s: (r:%s) => %s;", method.GetName(), i, o))
			return
		}
		if !cs {
			g.W(fmt.Sprintf("%s: (r:%s, cb:(a:{value: %s, done: boolean}) => void) => void;", method.GetName(), i, o))
			return
		}
		if !ss {
			g.W(fmt.Sprintf("%s: (r:() => {value: %s, done: boolean}) => %s;", method.GetName(), i, o))
			return
		}
		g.W(fmt.Sprintf("%s: (r:() => {value: %s, done: boolean}, cb:(a:{value: %s, done: boolean}) => void) => void;", method.GetName(), i, o))
	}
}
